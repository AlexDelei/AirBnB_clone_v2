#!/usr/bin/env bash
# automating git on the terminal

# Usage: ./git <file_1> <file_2> ... <commit message>

if [ "$#" -lt 2 ]; then
	echo "Usage: ./git <file_1> <file_2> ... <commit message>"
	exit 1
fi

# extracting commit message(last argument)
commit_msg="${!#}"

# checking if the last argument is a valid commit message
if [ -e "$commit_msg" ]; then
	echo "Error: the last argument should be a commit message, not a file"
	exit 1
fi

# Looping through the provided files and adding them to the index

# color code for a warning message
files_not_found=()
BLUE='\033[0;34m'
RED='\033[0;31m'
NONE='\033[0m'
for ((i = 1; i <= $# - 1; i ++)); do
	file="${!i}"

	if [ "$file" == "." ]; then
		git add .
		break
	elif [ -e "$file" ]; then
		git add "$file"
	else
		files_not_found+=("$file")
	fi
done
if [ "${#files_not_found[@]}" -gt 0 ]; then
	echo -e "${RED} Files not found: ${NONE}"
	for fnf in "${files_not_found[@]}"; do
		echo "  $fnf"
	done
	exit 1
else
	git commit -m "$commit_msg"
	echo -e "${BLUE}Committed changes with message: '$commit_msg'${NONE}"
	git push
	exit 1
fi
